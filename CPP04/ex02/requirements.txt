Not exactly. A C++ class becomes **abstract** if (and only if) it has **at least one** **pure virtual function**. Declaring a **pure virtual function** means writing:

```cpp
virtual void someMethod() const = 0;
```

within the class. This **`= 0`** is the key. It signals “There is **no** implementation in the base class,” and derived classes **must** override it. Here’s how it works in detail:

1. **Pure Virtual Function**
   - When you declare a method as `virtual void makeSound() const = 0;`, you’re saying:
     “This function is **not** implemented in this class—**any** subclass must provide its own implementation.”

2. **Abstract Class**
   - If a class has **at least one** pure virtual function, that class automatically becomes **abstract**.
   - An abstract class **cannot** be instantiated directly.
   - For example, if `class Animal` has `virtual void makeSound() const = 0;`, then you **cannot** do `new Animal()`. You can only create pointers or references to `Animal` that point to derived objects (like `new Dog()`).

3. **Normal Virtual vs. Pure Virtual**
   - **Normal virtual function**: `virtual void foo() const { /* default behavior */ }`
     - A derived class *may* override it, but the base class already has a default implementation.
     - The base class is **not** forced to be abstract.
   - **Pure virtual function**: `virtual void foo() const = 0;`
     - The base class cannot implement it (or if it does, it’s non-standard usage).
     - The base class **becomes** abstract.

So, to summarize:

- Simply **defining** or **“instantiating”** a regular member function does **not** make a class abstract.
- A class is abstract **only** when it has at least one **pure virtual** function declared (`= 0`). Once a class is abstract, it cannot be directly instantiated. You must inherit from it and override all its pure virtual functions if you want a concrete (non-abstract) derived class.
